---
title: '142 Linked List Cycle II'
date: 2025-06-24
category: 'leetcode'
tag: ['fast and slow pointer']
---

[142. Linked List Cycle II](https://leetcode.cn/problems/linked-list-cycle-ii/)

![Screenshot 2025-11-04 at 12.20.37 pm](assets/Screenshot%202025-11-04%20at%2012.20.37%E2%80%AFpm.png)

# 灵神的解法

https://leetcode.cn/problems/linked-list-cycle-ii/solutions/1999271/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-nvsq

![图解环形链表](https://pic.leetcode.cn/1741414978-wPTZwJ-lc142-3-c.png)

这意味着，==快指针比慢指针多走的路一定是环长的整数倍==（a是公共的）

而快指针多走的路等于慢指针走的路，所以慢指针走的路是环长的==整数倍==

那么 ` kc（环长）+ a` 一定在入环口

由于不知道`a`的值，让头节点和慢指针一起走，相遇点就是入环口

解：https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-

![Screenshot 2025-11-04 at 12.22.51 pm](assets/Screenshot%202025-11-04%20at%2012.22.51%E2%80%AFpm.png)

slow慢指针走了s步，fast快指针走了f步

根据：

1. f = 2s （快指针每次2步，路程刚好2倍）
2. f = s + nb (相遇时，刚好多走了n圈）

推出：s = nb (s走的步数刚好是n倍的环长)

从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。

如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步

为什么走a步之后会相遇：

入口为 a + nb，当n = 0时和 n属于正整数时都表示环的入口。

My solution:

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  let slow = head,
    fast = head
  if (!(fast && fast.next)) {
    // 特判空链表及只有一个元素的链表
    return null
  }
  while (fast && fast.next) {
    // 找到相遇点， fast 和 slow 指针分别走了 2n，n 个环的周长。
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      break
    }
  }
  if (fast !== slow) {
    // 无环
    return null
  }
  fast = head
  while (fast !== slow) {
    // fast 和 slow共同走a步，之后在入口相遇
    slow = slow.next
    fast = fast.next
  }
  return slow
}
```

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  let slow = head,
    fast = head
  while (true) {
    if (!(fast && fast.next)) {
      return null
    }
    slow = slow.next
    fast = fast.next.next
    if (fast === slow) {
      break
    }
  }
  fast = head
  while (fast !== slow) {
    fast = fast.next
    slow = slow.next
  }
  return slow
}
```
