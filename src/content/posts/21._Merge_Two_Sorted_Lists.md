---
title: 21. Merge Two Sorted Lists
date: 2025-11-10
category: 'leetcode'
---

[21. Merge Two Sorted Lists](https://leetcode.cn/problems/merge-two-sorted-lists/)

![Screenshot 2025-11-10 at 2.20.24 am](assets/Screenshot%202025-11-10%20at%202.20.24%E2%80%AFam.png)

# 方法一：递归

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
  if (list1 === null) {
    return list2
  } else if (list2 === null) {
    return list1
  } else if (list1.val < list2.val) {
    list1.next = mergeTwoLists(list1.next, list2)
    return list1
  } else {
    list2.next = mergeTwoLists(list1, list2.next)
    return list2
  }
}
```

# 方法二：迭代

为什么需要prev指针：

prev相当于合成后链表的最新节点，而i，j相当于待合成节点

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */

// 迭代
var mergeTwoLists = function (list1, list2) {
  const prehead = new ListNode(null)
  let prev = prehead
  let i = list1,
    j = list2
  while (i !== null && j !== null) {
    if (i.val < j.val) {
      prev.next = i
      i = i.next
    } else {
      prev.next = j
      j = j.next
    }
    prev = prev.next
  }
  // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
  prev.next = i === null ? j : i

  return prehead.next
}
```

https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu
