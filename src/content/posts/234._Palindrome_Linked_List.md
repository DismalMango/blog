---
title: 234. Palindrome Linked List
date: 2025-11-02
category: 'leetcode'
---

[234. Palindrome Linked List](https://leetcode.cn/problems/palindrome-linked-list/)

![Screenshot 2025-11-02 at 10.29.57 pm](assets/Screenshot%202025-11-02%20at%2010.29.57%E2%80%AFpm.png)

一句话思路：

找到链表的中间结点（快慢指针），从中间节点开始反转链表（反转链表），一一遍历比对。

![lc-midlist1.jpg](https://pic.leetcode.cn/1729048747-htsJVo-lc-midlist1.jpg)

第一张图中的 2→3，在反转链表后，并不会断开。第一张图反转链表后，我们得到了两条链表，一条是 1→2→3，另一条是 5→4→3。

3的内存地址是一样的是同一个3。

![lc-midlist2.jpg](https://pic.leetcode.cn/1729048754-HLNfqE-lc-midlist2.jpg)

第二张图中的 3→4，在反转链表后，并不会断开。第二张图反转链表后，我们得到了两条链表，一条是 1→2→3→4，另一条是 6→5→4。这意味着下面代码在写循环的时候，循环条件要判断 head
2是否为空而不是 head 是否为空。如果判断 head 是否为空，会错误地多循环一次，导致访问 head2.val 出现空指针异常。

![无标题的笔记本](assets/%E6%97%A0%E6%A0%87%E9%A2%98%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC.jpeg)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
// find middleNode
function middleNode(head) {
  let slow = head,
    fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next
    fast = fast.next.next
  }
  return slow
}
// 反转链表
function reverseLinkedList(head) {
  let prev = null,
    nxt = head
  while (nxt) {
    const tmp = nxt.next
    nxt.next = prev
    prev = nxt
    nxt = tmp
  }
  return prev
}
var isPalindrome = function (head) {
  let mid = middleNode(head)
  let midHead = reverseLinkedList(mid)
  while (midHead) {
    // 循环条件要判断 head 2 是否为空而不是 head 是否为空
    if (midHead.val !== head.val) {
      return false
    } else {
      midHead = midHead.next
      head = head.next
    }
  }
  return true
}
```

https://leetcode.cn/problems/palindrome-linked-list/solutions/2952645/o1-kong-jian-zuo-fa-xun-zhao-zhong-jian-rv0f3
